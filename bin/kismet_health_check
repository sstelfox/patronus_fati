#!/usr/bin/env ruby

$:.push(File.expand_path(File.join('..', '..', 'lib'), __FILE__))

require 'optparse'
require 'patronus_fati'
require 'timeout'

options = {
  'database' => 'sqlite::memory:?cache=shared',
  'port'   => 2501,
  'server' => '127.0.0.1'
}

OptionParser.new(nil, 32, '  ') do |opts|
  opts.on('-s', '--server SERVER', 'IP or hostname of running kismet server.') do |srv|
    options['server'] = srv
  end

  opts.on('-p', '--port PORT', 'Port that kismet server is running on.') do |port|
    options['port'] = port.to_i
  end
end.parse(ARGV)

def exception_logger(tag)
  yield
rescue Interrupt
  warn('Quitting...')
rescue => e
  puts "(#{tag}) Rescued from error: #{e.message}"
  puts e.backtrace
end

exception_logger('process') do
  PatronusFati.event_handler.on(:any) do |asset_type, event_type, msg, opts|
    puts "Server appears to be in good health"
    exit 0
  end

  begin
    Timeout.timeout(10) do
      connection = PatronusFati.setup(options['server'], options['port'], options['database'])
      connection.connect

      while (line = connection.read_queue.pop)
        next unless (obj = PatronusFati::MessageParser.parse(line))
        responses = PatronusFati::MessageProcessor.handle(obj)

        Array(responses).each { |msg| connection.write(msg) }
      end

      connection.disconnect
    end
  rescue Timeout::Error
    puts "Server did not send data. It appears to be locked up."
    exit 1
  end
end
