#!/usr/bin/env ruby

$:.push(File.expand_path(File.join('..', '..', 'lib'), __FILE__))

require 'optparse'
require 'patronus_fati'
require 'timeout'

options = {
  'database' => 'sqlite::memory:?cache=shared',
  'port'   => 2501,
  'server' => '127.0.0.1',
  'quiet' => false
}

OptionParser.new(nil, 32, '  ') do |opts|
  opts.on('-s', '--server SERVER', 'IP or hostname of running kismet server.') do |srv|
    options['server'] = srv
  end

  opts.on('-p', '--port PORT', 'Port that kismet server is running on.') do |port|
    options['port'] = port.to_i
  end

  opts.on('-q', '--quiet', 'Don\'t print anything to STDOUT just use the exit status') do
    options['quiet'] = true
  end
end.parse(ARGV)

def exception_logger(tag)
  yield
rescue Interrupt
  warn('Quitting...')
rescue => e
  puts "(#{tag}) Rescued from error: #{e.message}"
  puts e.backtrace
end

exception_logger('process') do
  PatronusFati.event_handler.on(:any) do |asset_type, event_type, msg, opts|
  end

  begin
    connection = PatronusFati.setup(options['server'], options['port'], options['database'])

    Timeout.timeout(10) do
      connection.connect

      while (line = connection.read_queue.pop)
        next unless (obj = PatronusFati::MessageParser.parse(line))
        puts "Server appears to be in good health" unless options['quiet']
        exit 0
      end
    end
  rescue Timeout::Error
    puts "Server did not send data. It appears to be locked up." unless options['quiet']
    exit 1
  ensure
    connection.disconnect
  end
end
