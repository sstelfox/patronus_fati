#!/usr/bin/env ruby

$:.push(File.expand_path(File.join('..', '..', 'lib'), __FILE__))

require 'optparse'
require 'dm-sqlite-adapter'
require 'patronus_fati'

options = {
  'database' => 'sqlite::memory:',
  'port'   => 2501,
  'server' => '127.0.0.1'
}

OptionParser.new(nil, 32, '  ') do |opts|
  opts.on('-d', '--db-path DB_PATH', 'Path where SQLite database will be stored') do |path|
    options['database'] = ('sqlite://%s' % File.expand_path(path))
  end

  opts.on('-s', '--server SERVER', 'IP or hostname of running kismet server.') do |srv|
    options['server'] = srv
  end

  opts.on('-p', '--port PORT', 'Port that kismet server is running on.') do |port|
    options['port'] = port.to_i
  end
end.parse(ARGV)

def exception_logger(tag)
  yield
rescue Interrupt
  warn('Quitting...')
rescue => e
  puts "(#{tag}) Rescued from error: #{e.message}"
  puts e.backtrace
end

exception_logger('process') do
  connection = PatronusFati.setup(options['server'], options['port'], options['database'])
  connection.connect

  PatronusFati.event_handler.on(:any) do |type, msg, opts|
    puts JSON.generate({type: type, data: msg, additional_data: opts, timestamp: Time.now})
  end

  while (line = connection.read_queue.pop)
    next unless (obj = PatronusFati::MessageParser.parse(line))
    responses = PatronusFati::MessageProcessor.handle(obj)

    Array(responses).each { |msg| connection.write(msg) }
  end
end

connection.disconnect
