#!/usr/bin/env ruby

$:.push(File.expand_path(File.join('..', '..', 'lib'), __FILE__))

require 'optparse'
require 'patronus_fati'

options = {
  'database' => 'sqlite::memory:',
  'port'   => 2501,
  'server' => '127.0.0.1'
}

OptionParser.new(nil, 32, '  ') do |opts|
  opts.on('-d', '--db-path DB_PATH', 'Path where SQLite database will be stored') do |path|
    options['database'] = ('sqlite://%s' % File.expand_path(path))
  end

  opts.on('-s', '--server SERVER', 'IP or hostname of running kismet server.') do |srv|
    options['server'] = srv
  end

  opts.on('-p', '--port PORT', 'Port that kismet server is running on.') do |port|
    options['port'] = port.to_i
  end
end.parse(ARGV)

def exception_logger(tag)
  yield
rescue Interrupt
  warn('Quitting...')
rescue => e
  puts "(#{tag}) Rescued from error: #{e.message}"
  puts e.backtrace
end

connection = PatronusFati::Connection.new(options['server'], options['port'])
connection.connect

exception_logger('process') do
  DataMapper.setup(:default, options['database'])
  DataMapper.finalize
  DataMapper.auto_upgrade!

  while (line = connection.read_queue.pop)
    next unless (obj = PatronusFati::MessageParser.parse(line))
    responses = PatronusFati::MessageProcessor.handle(obj)

    Array(responses).each do |msg|
      connection.write(msg)
    end
  end
end

connection.disconnect
